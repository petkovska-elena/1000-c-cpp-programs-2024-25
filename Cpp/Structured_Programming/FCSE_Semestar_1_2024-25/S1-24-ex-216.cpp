//
// Created by Elena Petkovska on 14.8.25.
//

//Auditoriski Vezbi 9

/*
   Задача: Броење на појави на облик „X“ во матрица

   Опис:
   – Од стандарден влез се читаат димензиите на матрица m и n (m редици, n колони),
	 потоа се читаат m редици со по n цели броеви.
   – Обликот „X“ е составен од точно 5 елементи со вредност 1:
		центар со вредност 1 и неговите четири дијагонални соседи исто со вредност 1.
	 Формално, за некој елемент (i, j) важи облик „X“ ако:
		a[i][j] == 1,
		a[i-1][j-1] == 1, a[i-1][j+1] == 1, a[i+1][j-1] == 1, a[i+1][j+1] == 1.
   – Да се избројат сите појави на ваков „X“ во рамки на матрицата.
   – Се претпоставува дека не постои преклопување на елементи помеѓу два различни „X“
	 (не делат исти ќелии), а пребарувањето е одлево-надесно и одгоре-надолу.
   – Да се испечати само бројот на појави.

   Влез:
	 m n
	 a[0][0] a[0][1] ... a[0][n-1]
	 ...
	 a[m-1][0] ...      a[m-1][n-1]

   Излез:
	 (цел број) – колку „X“ има во матрицата.

   Забелешка:
   – Ако m < 3 или n < 3, невозможно е да постои „X“, па резултатот е 0.
*/

#include <iostream>
using namespace std;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int m, n;
	if (!(cin >> m >> n)) return 0;

	// Безбедни горни граници; при потреба зголемете.
	const int MAXM = 200;
	const int MAXN = 200;
	int a[MAXM][MAXN];

	for (int i = 0; i < m; ++i) {
		for (int j = 0; j < n; ++j) {
			cin >> a[i][j];
		}
	}

	// Ако нема доволно редици/колони, нема X.
	if (m < 3 || n < 3) {
		cout << 0 << '\n';
		return 0;
	}

	int countX = 0;

	// Секој можен центар мора да е внатрешна ќелија (не на раб),
	// за да постојат четирите дијагонални соседи.
	for (int i = 1; i <= m - 2; ++i) {
		for (int j = 1; j <= n - 2; ++j) {
			if (a[i][j] == 1 &&
				a[i-1][j-1] == 1 && a[i-1][j+1] == 1 &&
				a[i+1][j-1] == 1 && a[i+1][j+1] == 1) {
				++countX;
				}
		}
	}

	cout << countX << '\n';
	return 0;
}